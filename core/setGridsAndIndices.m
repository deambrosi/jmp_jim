function [grids, indexes] = setGridsAndIndices(dims)
% SETGRIDSANDINDICES Construct the model's state grids and reshaping indices.
%
%	SYNTAX:
%		[grids, indexes] = setGridsAndIndices(dims)
%
%	INPUTS:
%		dims (struct)	Structure generated by `setDimensionParam` that collects
%			the integer counts for every state dimension used by the
%			dynamic equilibrium solver. Required fields are:
%				.Na (1x1 double)	Number of nodes in the coarse asset grid.
%				.na (1x1 double)	Number of nodes in the fine asset grid used
%								for post-decision interpolation.
%				.S  (1x1 double)	Total number of composite productivity-amenity
%								states (S = K * B).
%				.K  (1x1 double)	Number of productivity (eta) states.
%				.B  (1x1 double)	Number of amenity (psi) states.
%				.N  (1x1 double)	Number of geographic locations.
%				.H  (1x1 double)	Number of help program states.
%
%	OUTPUTS:
%		grids (struct)	Container with model grids:
%				.agrid		[dims.Na x 1] vector with a concave coarse
%						asset grid for value functions.
%				.ahgrid		[dims.na x 1] vector with a uniform fine
%						asset grid for policy interpolation.
%				.psi			[dims.B x 1] vector of amenity levels used
%						to construct the composite state index.
%
%		indexes (struct)	Collection of multidimensional index arrays that allow
%				reshaping value, policy, and migration objects without
%				recomputing `ndgrid` calls. Each field stores arrays with
%				explicit dimensions documented below.
%
%	NOTES:
%		The asset grids rely on the helper routine `nodeunif`, which builds
%		non-uniform grids with controlled curvature. Productivity levels are
%		obtained elsewhere and are implied by the composite state index.
%
%	AUTHOR: Agustin Deambrosi
%	DATE: October 2025
% =========================================================================

	%% 1. Asset grids (coarse and fine)
	%	Construct lower and upper bounds together with curvature to control the
	%	spacing of the coarse grid that supports the value function iteration.
	lb.a				= 0;				% Lower bound of asset holdings (in model units)
	ub.a				= 40;			% Upper bound of asset holdings (in model units)
	ca				= 3;				% Curvature parameter for the coarse grid density

	%	Generate the coarse asset grid `agrid` as a [dims.Na x 1] vector with a
	%	concave spacing and the fine grid `ahgrid` as a [dims.na x 1] uniform vector.
	grids.agrid	= nodeunif(dims.Na, 0, (ub.a - lb.a)^(1/ca)).^ca + lb.a;
	grids.ahgrid	= nodeunif(dims.na, lb.a, ub.a);

	%% 2. Productivity and amenity grids
	%	The productivity grid is defined elsewhere; here we build the amenity grid
	%	`psi` as a [dims.B x 1] evenly spaced vector on the unit interval.
	%grids.eta	= linspace(0.8, 4, dims.K);
	%grids.psi	= linspace(0.7, 2.2, dims.B);
	grids.psi		= linspace(0, 1, dims.B);

	%% 3. Indexing for V (main state grid): dimensions [dims.S x dims.Na x dims.N]
	%	The `ndgrid` call expands composite state (s), asset (a), and location (N)
	%	indices so that value and policy arrays can be reshaped without loops.
	[I_s, I_a, I_N]	= ndgrid(1:dims.S, 1:dims.Na, 1:dims.N);

	%% 4. Indexing for R (post-saving grid): dimensions [dims.S x dims.Na x dims.N x dims.na]
	%	The tensors below track the post-decision state that includes the fine asset
	%	grid. `I_ep` and `I_psip` recover productivity (eta) and amenity (psi)
	%	components from the composite index `s` so that shocks can be applied.
	[I_sp, I_ap, I_Np, I_app]	= ndgrid(1:dims.S, 1:dims.Na, 1:dims.N, 1:dims.na);
	I_ep		= floor((I_s - 1) / dims.B) + 1;	% [dims.S x dims.Na x dims.N] eta indices
	I_psip	= mod(I_s - 1, dims.B) + 1;		% [dims.S x dims.Na x dims.N] psi indices

	%% 5. Migration-related indexing: diagonal extraction in [dims.S x dims.Na x dims.N x dims.H]
	%	Intermediate arrays evaluate the subset of migrants that stay in the origin
	%	location. The subscript conversion `II` produces a linear index tensor with
	%	the same dimensions as the input arrays, flagging stayers along the diagonal
	%	of the origin-destination pair.
	[I_sr, I_ar, I_ir, I_hr]	= ndgrid(1:dims.S, 1:dims.Na, 1:dims.N, 1:dims.H);
	II		= sub2ind([dims.S, dims.Na, dims.N, dims.N, dims.H], ...
				 I_sr, I_ar, I_ir, I_ir, I_hr);	% Linear indices for stayers

	%% 6. Full migration indexing: dimensions [dims.S x dims.Na x dims.N x dims.N x dims.H]
	%	These tensors enumerate every origin-destination-help combination required
	%	to build the transition matrices for migration choices.
	[I_sm, I_am, I_Nm, I_jm, I_hm]	= ndgrid(1:dims.S, 1:dims.Na, 1:dims.N, 1:dims.N, 1:dims.H);

	%% 7. Sizes of indexing structures
	%	Store the array sizes so that downstream routines can reshape using the
	%	same dimension ordering without recomputing them.
	sz		= size(I_s);
	szp	= size(I_sp);
	szm	= size(I_sm);

	%% 8. Pack outputs
	%	Collect each tensor in the `indexes` structure to make the state space
	%	layout explicit for the value function and migration solvers.
	indexes.I_s	= I_s;
	indexes.I_a	= I_a;
	indexes.I_N	= I_N;

	indexes.I_sp	= I_sp;
	indexes.I_ap	= I_ap;
	indexes.I_Np	= I_Np;
	indexes.I_app	= I_app;
	indexes.I_ep	= I_ep;
	indexes.I_psip	= I_psip;

	indexes.I_sm	= I_sm;
	indexes.I_am	= I_am;
	indexes.I_Nm	= I_Nm;
	indexes.I_jm	= I_jm;
	indexes.I_hm	= I_hm;
	indexes.II	= II;

	indexes.sz	= sz;
	indexes.szp	= szp;
	indexes.szm	= szm;

end